---
tags:
  - programming/Algorythem
  - programming/Algorythem/Sort
subject: DataStructure
aliases:
  - 퀵 소트
---
퀵 정렬의 주요 특징은 다음과 같습니다:

1. **분할 정복 [[알고리즘]]**: 퀵 정렬은 분할 정복 방식을 사용합니다. 즉, 큰 문제를 작은 문제로 나누어 해결한 후 다시 합치는 방식으로 작동합니다.

2. **피벗 선택**: 퀵 정렬은 배열에서 임의의 원소를 선택하여 피벗으로 사용합니다. 일반적으로 배열의 마지막 원소를 피벗으로 사용하지만, 다양한 피벗 선택 전략이 존재합니다.

3. **분할 과정**: 피벗을 기준으로 배열을 두 부분으로 나눕니다. 피벗보다 작은 원소들은 왼쪽 부분 배열로, 피벗보다 큰 원소들은 오른쪽 부분 배열로 이동합니다.

4. **재귀적 정렬**: 분할된 두 부분 배열을 각각 재귀적으로 퀵 정렬합니다. 이 과정을 반복하여 전체 배열이 정렬됩니다.

5. **공간 복잡도**: 퀵 정렬은 추가적인 메모리 공간이 필요하지 않아 공간 복잡도가 O(1)입니다.

퀵 정렬의 작동 과정을 단계별로 살펴보면 다음과 같습니다:

1. 배열에서 임의의 원소를 선택하여 피벗으로 지정합니다.
2. 배열을 두 부분으로 나눕니다. 왼쪽 부분에는 피벗보다 작은 원소들, 오른쪽 부분에는 피벗보다 큰 원소들이 있습니다.
3. 왼쪽 부분 배열과 오른쪽 부분 배열을 각각 재귀적으로 퀵 정렬합니다.
4. 정렬된 왼쪽 부분 배열, 피벗, 정렬된 오른쪽 부분 배열을 합쳐 최종 정렬된 배열을 만듭니다.

퀵 정렬의 의사코드는 다음과 같습니다:

```
QuickSort(A, left, right)
    if left < right
        pivot = Partition(A, left, right)
        QuickSort(A, left, pivot-1)
        QuickSort(A, pivot+1, right)

Partition(A, left, right)
    pivot = A[right]
    i = left - 1
    for j = left to right-1
        if A[j] < pivot
            i = i + 1
            Swap(A, i, j)
    Swap(A, i+1, right)
    return i+1
```

위의 의사코드를 설명하면 다음과 같습니다:

1. `QuickSort` 함수:
    - 왼쪽 인덱스 `left`가 오른쪽 인덱스 `right`보다 작으면 다음을 수행합니다.
	    - `Partition` 함수를 호출하여 피벗 인덱스를 구합니다.
	    - 피벗을 기준으로 왼쪽 부분 배열(`left` ~ `pivot-1`)과 오른쪽 부분 배열(`pivot+1` ~ `right`)을 각각 재귀적으로 퀵 정렬합니다.
1. `Partition` 함수:
    - 맨 오른쪽 원소를 피벗으로 지정합니다.
    - `i`를 `left-1`로 초기화합니다.
    - `left`부터 `right-1`까지 반복하면서 다음을 수행합니다:
        - `A[j]`가 피벗보다 작으면 `i`를 `1` 증가시키고 `A[i]`와 `A[j]`를 swap합니다.
    - `A[i+1]`과 `A[right]`를 `swap`합니다.
    - `i+1`을 반환합니다.

이 과정을 반복하면 전체 배열이 정렬됩니다. 퀵 정렬은 ==평균적으로 매우 빠른 수행 속도==를 보이지만, **최악의 경우** 시간 복잡도가 [[빅-오 표기법|O(n^2)]]가 될 수 있습니다. 이를 방지하기 위해 다양한 피벗 선택 전략이 사용됩니다. 
![[뷕 정렬.png]]