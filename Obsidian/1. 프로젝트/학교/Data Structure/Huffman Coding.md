허프만 코딩은 데이터 압축에서 자주 사용되는 효율적인 코딩 기법 중 하나이다. 이 방법은 문자나 기호의 빈도에 따라 가변 길이 코드를 할당하며, 더 자주 등장하는 문자에는 짧은 코드를, 덜 자주 등장하는 문자에는 긴 코드를 할당하여 전체 메시지를 표현하는 데 필요한 비트 수를 최소화한다.

# 인코딩
1. **빈도 계산**: 입력 데이터에서 각 문자의 빈도를 계산한다.
2. **우선순위 큐 초기화**: 문자와 그 빈도를 사용하여 노드를 만들고, 이 노드들을 우선순위 큐(빈도 오름차순)에 삽입한다.
3. **트리 구성**:
   - 우선순위 큐에서 빈도가 가장 낮은 두 노드를 추출한다.
   - 이 두 노드의 빈도를 합한 새로운 부모 노드를 만들고, 두 노드를 부모 노드의 자식으로 설정한다.
   - 새로운 부모 노드를 다시 우선순위 큐에 삽입한다.
   - 이 과정을 큐에 하나의 노드만 남을 때까지 반복한다. 남은 마지막 노드가 허프만 트리의 루트가 된다.
4. **코드 할당**:
   - 허프만 트리를 순회하며, 루트부터 각 리프(문자) 노드까지의 경로를 따라 코드를 할당한다. 왼쪽 자식으로 가는 경로는 "0"으로, 오른쪽 자식으로 가는 경로는 "1"로 표현한다.
# 디코딩
1. **Huffman 트리 생성**: 디코딩을 위해서는 먼저 인코딩에 사용된 Huffman 트리를 알고 있어야 한다. 인코딩 과정에서 생성된 Huffman 트리를 준비한다.
2. **코드 읽기 및 트리 탐색**:
   - 인코딩된 비트 스트림을 처음부터 한 비트씩 읽기 시작한다.
   - Huffman 트리의 루트 노드에서부터 시작하여 비트를 하나씩 읽어가며 트리를 탐색한다.
     - 읽은 비트가 '0'이면 현재 노드의 왼쪽 자식 노드로 이동한다.
     - 읽은 비트가 '1'이면 현재 노드의 오른쪽 자식 노드로 이동한다.
3. **문자 복원**:
   - 자식 노드로 이동할 때마다 현재 노드가 리프 노드인지 확인한다.
   - 리프 노드에 도달하면 해당 노드의 문자를 복원하고, 다시 루트 노드로 돌아가 다음 비트를 읽기 시작한다.
   - 이 과정을 인코딩된 비트 스트림의 끝까지 반복한다.
4. **디코딩 완료**: 
   - 모든 비트를 읽고 나면, 원래의 문자가 복원된다.
### 예시:

- 예를 들어, 인코딩된 비트 스트림이 `1011001`이고, Huffman 트리가 다음과 같다고 가정한다:
  ```
          (*)
         /   \
       (A)   (*)
             /   \
           (B)   (C)
  ```
  - `1`을 읽으면 오른쪽으로 이동하여 `*` 노드에 도착한다.
  - `0`을 읽으면 왼쪽으로 이동하여 `B` 노드에 도착한다 (첫 번째 문자 복원: `B`).
  - 다시 루트로 돌아가서 `1`을 읽으면 오른쪽으로 이동하여 `*` 노드에 도착한다.
  - 또 `1`을 읽으면 오른쪽으로 이동하여 `C` 노드에 도착한다 (두 번째 문자 복원: `C`).
  - 다시 루트로 돌아가서 `0`을 읽으면 왼쪽으로 이동하여 `A` 노드에 도착한다 (세 번째 문자 복원: `A`).
  - 마지막으로 `0`을 읽으면 왼쪽으로 이동하여 `A` 노드에 도착한다 (네 번째 문자 복원: `A`).
# 특징
- **무손실 압축**: 원본 데이터를 압축하고 해제하더라도 데이터 손실이 발생하지 않는다.
- **최적 인코딩**: 주어진 문자 집합에 대해 평균 코드 길이를 최소화하는 가장 효율적인 방법 중 하나이다.
- **가변 길이 코드**: 더 자주 등장하는 문자에는 짧은 코드가, 덜 자주 등장하는 문자에는 긴 코드가 할당된다.

허프만 코딩은 효율성과 무손실 압축 특성 덕분에 파일 압축, 데이터 전송 최적화 등 다양한 분야에서 널리 사용된다. 