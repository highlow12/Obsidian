---
tags:
  - 수정중
---

# S: 단일 책임 원칙
Single responsibility principle
> 한 클래스는 하나의 책임만 가져야 한다

모든 클래스는 단 하나의 책임만 가지며 클래스가 제공하는 모든 기능은 이 책임과 깊이 관련되어야 한다는 원칙이다
## 어떤 클래스나 모듈은 변경하려는 단 하나의 이유만을 가지고 있어야 한다
- **예시**: 만약 '사용자'를 관리하는 클래스가 있다고 가정해 보겠습니다. 이 클래스가 사용자 정보를 저장하는 기능과 사용자에게 이메일을 보내는 기능을 모두 가지고 있다면, 이는 단일 책임 원칙을 위반한 것입니다. 왜냐하면 사용자 정보 저장과 이메일 전송은 서로 다른 책임이기 때문입니다.
- **올바른 설계**: 사용자 정보를 처리하는 클래스와 이메일 전송을 처리하는 클래스를 나누면, 각각의 클래스가 하나의 책임만 가지게 됩니다. 이렇게 하면 코드의 유지보수성과 가독성이 향상되고, 변경이 필요할 때 영향을 받는 부분이 줄어듭니다.
# O: 개방-폐쇄 원칙
Open/closed principle
> 소프트웨어는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다

**확장에 대해 열려 있다.**
이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
**수정에 대해 닫혀 있다**
모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
## 어떤 모듈이나 클래스는 기능을 확장할수 있어야 하지만 기존 코드를 수정해서는 안 된다
- **예시**: 만약 '결제 처리'를 담당하는 클래스가 있다고 가정해 보겠습니다. 이 클래스가 신용카드 결제만 처리하도록 설계되어 있다면, 나중에 추가로 페이팔 결제나 다른 결제 방식을 지원하려면 기존 클래스를 수정해야 합니다. 이는 OCP를 위반하는 것입니다.
- **올바른 설계**: 대신에 결제 처리를 인터페이스로 정의하고, 각 결제 방식(신용카드, 페이팔 등)을 구현하는 별도의 클래스를 만들어서 추가하면 됩니다. 이렇게 하면 새로운 결제 방식이 필요할 때 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하기만 하면 됩니다.
또한 이것은 추상화에 객체지향의 핵심 개념이다
# L: 리스코프 치환 원칙
Liskov substitution principle
> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다

## Q(x)를 자료형 T의 객체 x에 대해 증명할 수 있는 속성이라 하자. 그렇다면 S가 T의 하위형이라면 Q(Y)는 자료형 S의 객체 y에 대해 증명할 수 있어야 한다.
# I: 인터페이스 분리 원칙
Interface segregation principle
> 특정 클라이언트를 위한 전용 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
# D: 의존관계 역전 원칙
Dependency inversion principle
> 구체화에 의존하지 말고 추상화에 의존하라
