---
tags:
  - school
subject: Computer Structure/System
---

# 차례
1. CPU의 기본 구조
2. 면령어 실행
3. 명령어 파이프라이닝
4. 명령어 세트
# 0. CPU의 기능
#### 프로그램 수행
##### 모든 명령어에 대해 공통적으로 수행하는 기능
- cpu가 기억장치에 저장된 명령어를 실행
- **명령어 인출** (Instruction Fetch): 기억장치로부터 명령어를 읽음
- **명령어 해독** (Instruction Decode): 수행해야 할 동작을 결정하기 위해 인출된 명령어를 해독
##### 명령어에 따라 필요한 경우에 수행하는 기능
- **데이터 인출** (Data Fetch): 명령얼 실행을 위하여 데이터가 필요한 경우  기억장치 또는 입출력장치로부터 그 데이터를 읽음
- **데이터 처리** (Data Process): 데이터에 대한 산술적 또는 논리적 연산을 수행
- **데이터 쓰기** (Data Store): 수행한 결과를 저장
# 1. CPU의 기본 구조
- 산술논리연산장치(Arithmetic and Logical Unit: ALU) 
- 레지스터 세트(Register Set)
- 제어 유니트(Control Unit)
![[Computer Basic Architecture.png|400]]
## CPU의 내부 구성요소
### ALU
- 각종 산술 연산들과 논리 연산을 수행하는 회로들로 이루어진 하드웨어
### 레지스터 세트
- cpu 내부 레지스터의 집합
- 컴퓨터의 기억장치 중, 액세스 속도가 가장 빠름
- cpu 내부에 포함할수 있는 레지스터들의 수가 제한됨
	- 특수목적, 일반 목적용 레지스터들
### 제어 유닛
- 명령어를 해석하고 실행하기 위한 제어 신호들을 순차적으로 보내는 하드웨어
- 명령어 실행에 필요한 정보들의 전송 통로와 방향 지정
- cpu 내부 요소와 시스템 구성 요소들의 동작 시간 결정
### CPU 내부 버스
- ALU - 레지스터들 사이에서 데이터 이동을 위한 데이터 선과 제어 유닛으로부터 발생되는 제어 신호 선
- 외부의 시스템 버스와는 직접 연결되지 않으며 반드시 버퍼 레지스터들 또는 시스템 버스 인터페이스를 통하여 시스테 버스와 접속
# 2. 명령어 실행
## 명령어 사이클 (Instruction Cycle)
- cpu 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정
- cpu가 프로그램 실행을 실행한 순간부터 전원원을 끄는 등의 회복 불가능한 오류가 발생하여 중단될 때까지 반복
## 기본 명령어 사이클
- **인출 사이클** (Fetch Cycle): CPU가 기억장치로부터 명령어를 읽어오는 단계
- **실행 사이클** (Excution Cucle): 명령어를 실행하는 단계
#### 명령어 실행에 필요한 CPU 내부 레지스터들
- 프로그램 카운터: 다음에 실행할 명령어의 주소를 저장하는 레지스터입니다.
- 누산기: 연산 결과를 일시적으로 저장하는 레지스터입니다.
- 명령어 레지스터: 현재 실행 중인 명령어를 저장하는 레지스터입니다.
- 메모리 주소 레지스터: 메모리에서 읽거나 쓸 주소를 저장하는 레지스터입니다.
- 메모리 버퍼 레지스터: 메모리와 CPU 사이에서 데이터를 임시로 저장하는 레지스터입니다.
### 인출 사이클
<font color="#d83931">메모리에 저장된 명령어를 인출</font>
인출 사이클의 마이크로 연산 [^1]
0. MAR <- PC
	-  현재의 PC 내용을 CPU내부 버스를 통하여 MAR로 전송
1. MBR <- M\[MAR\], PC + 1
	- 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통하여 MBR로 적재되며 PC의 내용에 1을 더한다
2. IR <- MBR
	- MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동
(단위는 CPU클럭의 주기이다 )
### 실행 사이클
<font color="#d83931">명령어 코드를 해독하고 필요한 연산을 수행</font>
**연산의 종류**
- 데이터 이동: CPU <-> 기억장치, CPU <-> I/O장치
- 데이터 처리: 데이터에 대한 산술 및 논리 연산 수행
- 데이터 저장: 연산 결과 및 입력장치로부터 읽은 데이터를 기억장치에 저장
- 제어: 프로그램의 실행 순서를 결정
>[!note]- 기본적인 명령어 형식의 구성
> - 연산 코드 (Operation code)
> 	- cpu가 수행할 연산을 지정
> - 오퍼랜드(Operand)
> 	- 명령어 실행에 필요한 데이터가 저장된 주소 (addr)
> 
> |   연산 코드  |   오퍼랜드(addr)  |
> | --- | --- |

>[!example]+ 사례1. LOAD addr 명령어
> 기억장치에 저장되어 있는 데이터를 CPU 내부 레지스터인 AC로 이동하는 명령어
> 
> 0. MAR <- IR(addr)
> 	- 명령어 레지스터에 있는 IR로부터 명령어의 주소 부분을 MAR로 전송
> 1. MBR <- M\[MAR\]
> 	- 그 주소가 지정한 기억장소로부터 데이터를 인출하여 MBR로 전송
> 2. AC <- MBR
> 	- 그 데이터를 AC에 적재

>[!example]+ 사례 2. STA addr 명령어  
> AC 레지스터의 내용을 기억장치에 저장하는 명령어  
>  
> 0. MAR <- IR(addr)  
>    - 데이터를 저장할 기억장치의 주소를 MAR로 전송  
> 1. MBR <- AC  
>    - 저장할 데이터를 버퍼 레지스터인 MBR로 이동  
> 2. M[MAR] <- MBR  
>    - MBR의 내용을 MAR이 지정하는 기억장소에 저장   

>[!example]+ 사례 3. ADD addr 명령어  
> 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어  
>  
> 0. MAR <- IR(addr)  
>    - 데이터를 저장할 기억장치의 주소를 MAR로 전송  
> 1. MBR <- M[MAR]  
>    - 저장할 데이터를 버퍼 레지스터인 MBR로 이동  
> 2. AC <- AC + MBR  
>    - 그 데이터와 AC의 내용을 더하고 결과값을 다시 AC에 저장   

> [!note]+ 사례 4. JUMP addr 명령어
> 오퍼랜드가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기(branch) 명령어
> 
> 1. PC <- IR(addr)
> 	- 명령어의 오퍼랜드(분기할 목적지 주소)가 PC에 저장
> 	- 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로 분기가 발생
### 인터럽트 사이클(interrupt cycle)
**인터럽트**
- 다른 모듈들(I/O or 기억장치)이 프로세서의 정상적인 처리를 중단할수 있는 메커니즘
- I/O 동작이 수행되는 동안에도 프로세서는 다른 명령어들을 실행 -> <font color="#d83931">처리 효율을 향상</font>
**외부로부터 인터럽트 요구가 들어왔을때**
- CPU는 원래의 프로그램 수앵을 중단하고 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행
인터럽트 서비스 루틴(Interrupt service routine: ISR)
- 인터럽트를 처리하기 위하여 수행하는 프로그램 루틴
> [!note]+ 인터럽트 종류
>
>| 구분 | 설명 |
>|------|------|
>| 프로그램 | 산술 오버플로우, 0으로 나누기, 잘못된 기계어 명령어 실행 시도, 또는 사용자의 허용된 메모리 공간 외부 참조와 같은 명령어 실행의 결과로 발생하는 조건에 의해 생성됨 |
>| 타이머 | 프로세서 내의 타이머에 의해 생성됨. 운영체제가 정기적으로 특정 기능을 수행할 수 있게 함 |
>| 입출력(I/O) | 입출력 컨트롤러에 의해 생성되며, 작업의 정상 완료를 알리거나 다양한 오류 조건을 신호로 알리기 위해 사용됨 |
>| 하드웨어 오류 | 전원 오류나 메모리 패리티 오류와 같은 장애에 의해 생성됨 |

#### 인터럽트 처리
**인터럽트가 들어왔을 때 CPU는**
- 어떤 장치가 인터럽트를 요구했는지 확인
- 해당 인터럽트 루틴(ISR)을 호출
> [!note]- 명령어 사이클 순서도
> ```mermaid
> graph TD
>    A[시작] --> B[명령어 인출]
>    B --> C[명령어 실행]
>    C --> D{인터럽트\n가능?}
>    D -->|아니오| B
>    D -->|예| E[인터럽트 검사\n및 처리 준비]
>    E --> F[종료]
> ```

>[!example]+ 인터럽트 사이클의 마이크로 연산  
>  
> 0. MBR <- PC  
>    - PC의 내용이 MBR로 전송  
> 1. MAR <- SP, PC <- ISR의 시작 주소  
>    - SP[^2]의 내용이 MAR로 전송되고, PC의 내용은 ISR의 시작 주소로 변경  
> 2. M[MAR] <- MBR  
>    - MBR에 저장되어 있던 원래 PC의 내용이 스택에 저장   
##### 다중 인터럽트
인터럽트 서비스 루틴 수행 중 다른 인터럽트 발생
**다중 인터럽트의 처리 방법**
- 인터럽트 불가능 (interrupt disabled) ( = 순차적 인처럽트 처리)
	- CPU가 ISR을 수행하고 있는 도중에는 새로운 인터럽트를 받아도 ISR을 수행하지 못하도록 방지
- 우선순위에 의한 인터럽트 처리 ( = Nasted 인터럽트 처리)
	- 스택에 중단된 ISR 주소도 추가 저장
	- 인터럽트의 우선순위에 따라서 인터럽트 처리
	- 우선순위가 더 높은 인터럽트가 들어오면 현재의 ISR을 중단하고 새 인터럽트 처리
> [!white]- 순차적 인터럽트 처리 방법 시퀀스 다이어그램
> ```mermaid
> sequenceDiagram
>     participant P as Process
>     participant CPU
>     participant ISR1 as ISR #1
>     participant ISR2 as ISR #2
>     
>     P->>+CPU: 프로세스 실행
>     CPU-->>CPU: 인터럽트 1 발생
>     CPU->>CPU: 인터럽트 비활성화
>     CPU->>+ISR1: ISR1 실행
>     Note right of ISR1: 모든 인터럽트 무시됨
>     CPU-->>CPU: 인터럽트 2 발생<br/>(대기 상태)
>     ISR1->>-CPU: ISR1 완료
>     CPU->>CPU: 인터럽트 활성화
>     CPU->>CPU: 인터럽트 비활성화
>     CPU->>+ISR2: ISR2 실행
>     Note right of ISR2: 모든 인터럽트 무시됨
>     ISR2->>-CPU: ISR2 완료
>     CPU->>CPU: 인터럽트 활성화
>     CPU->>-P: 프로세스 복귀
> ```

> [!white]- Nasted 인터럽트 처리 방법 시퀀스 다이어그램
> ```mermaid
> sequenceDiagram
>     participant P as Process
>     participant CPU
>     participant ISR1 as ISR #1<br/>(낮은 우선순위)
>     participant ISR2 as ISR #2<br/>(높은 우선순위)
>     
>     P->>+CPU: 프로세스 실행
>     CPU-->CPU: 인터럽트 1 발생
>     CPU->>+ISR1: ISR1 실행
>     Note right of ISR1: 높은 우선순위<br/>인터럽트만 허용
>     CPU-->CPU: 인터럽트 2 발생
>     Note right of CPU: 우선순위 확인
>     ISR1-->ISR1: ISR1 컨텍스트 저장
>     CPU->>+ISR2: ISR2 실행
>     Note right of ISR2: 중첩 인터럽트 처리
>     ISR2->>-CPU: ISR2 완료
>     CPU->>ISR1: ISR1 컨텍스트 복원
>     ISR1->>-CPU: ISR1 완료
>     CPU->>-P: 프로세스 복귀
> ```
### 간접 사이클
**일반적인 명령어**
- 오퍼랜드에 데이터가 저장된 기억장치 주소가 포함
**간접 주소지정 방식** (indirect addressing mode)
- 명령어에 포함된 주소를 통해 실제 데이터가 저장된 메모리의 위치를 지정하는 방식
- 즉, 명령어 자체에는 데이터의 주소가 아닌, 데이터가 있는 메모리의 주소를 가리키는 주소가 포함되어 있다
**간접 사이클의 마이크로 연산**
0. MAR <- IR(addr)  
   - IR에서 주소 필드를 읽어 MAR에 저장합니다. 이 단계에서는 다음에 접근할 메모리 주소를 지정합니다.
1. MBR <- M\[MAR\]  
   - MAR에 저장된 주소를 사용하여 메모리에서 데이터를 읽어들여 MBR에 저장합니다. 이 단계에서는 지정된 메모리 주소의 내용을 가져옵니다.
2. IR(addr) <- MBR  
   - MBR에 저장된 데이터를 IR의 주소 필드에 저장합니다. 이 단계에서는 읽어온 데이터를 명령어로 변환하여 다음 실행을 준비합니다.
# 명령어 파이프라이닝
CPU의 프로그램 처리 속도를 높이기 위해서 ==CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술==
## 2-단계 명령어 파이프라인 (two-stage instruction pipeline)
명령어를 실행하는 하드웨어를 <font color="#4bacc6">인출 단계</font>(fetch stage)와 <font color="#4bacc6">실행 단계</font>(excute stage)의 독립적인 파이프라인 모듈들로 분리
- 두 단계들에 동일한 클럭을 가하여 동작 시간을 일치
	- 첫 번째 클럭 주기
		- 인출 단계: 명령어 인출
		- 실행 단계: 아직 실행 안함
	- 두 번째 클럭 주기
		- 인출 단계: 실행 단계로 인출된 명령어 보내고 다음 명령어 인출
		- 실행 단계: 전달된 명령어 실행
	- 세 번째 클럭 주기
		- 여기서부터 동일함
**명령어 선인출** ( instruction prefetch)
- 다음에 실행될 명령어를 미리 인출
2단계 파이프라인을 이용하면 명령어 처리 속도가 두배 향상
(일반적으로 단계 수만큼 속도 향상)
**문제점**
- 파이프라인 효율 저하
	- 일반적으로 실해단계의 소요 시간이 인출단계 보다 김
	- 두 단계의 처리 시간이 동일하지 않으면 두 배의 속됴 향상 불가
**해결책**
- 파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함
- 파이프라인 단계의 수를 늘리면 전체적으로 속도 향상도 더 높아짐
## 4-단계 파이프라인의 예
- 명령어 인출(Instruction fetch: IF): 다음 명령어를 기억장치로부터 인출
- 명령어 해독(Instruction decode: ID): 해독기(decoder)를 이용하여 명령어 해석
- 오퍼랜드 인출(Operand fetch: OF): 기억장치로부터 오퍼랜드를 인출
- 실행(Excute): 지정된 연산을 수행
-> 각 단계에서 소요되는 시간이 거의 비슷함
## 파이프라인에 의한 속도 향상
가정
- 파이프라인의 단계 수 = $k$
- 실행할 명령어들의 수 = $N$
- 파이프라인에 의한 전체 명령어 실행 시간 $T$:
	- 첫 번쨰 명령어를 실행하는데 $k$ 주기가 걸린다
	- 나머지 $(N-1)$개의 명령어들은 각각 한 주기씩만 소요됨
$$T=k+(N-1)$$
- 파이프라인 되지 않은 경우의 $N$개의 명령어들의 실행 시간 $T$:
$$ T = k \times N$$
즉 결과적으로 속도 향상 배율은 다음과 같다
$$S_p = \frac{k \times N}{k + (N - 1)}$$
> [!example]+ 
> $k = 4$ 일때
>
> | $N$        | $S_p$       |
> | :--------: | :-------------------: |
> | 100      | 400/103 = 3.88      |
> | 1000     | 4000/1003 = 3.99    |
> | 10000    | 40000/10003 = 3.998 |
> | $\infty$ | 4                   |

## 파이프라인의 성능 저하 요인들
- 모든 명령어들이 파이프라인 전체를 거치지는 않음
	- 어떤 명령어는 오퍼랜드를 인출할 필요가 없음
	- 그러나 파이프라인 하드웨어를 단숭하게 하기 위해 모든 명령어가 네 단계를 모두 거치게 설계 -> OF 단계를 생략하는 명령어 = 한 사이클 소모
- 파이프라인의 클럭은 처리 시간이 가장 오래 걸리는 단계가 기준
- IF단계와 OF단계가 동시에 기억장치를 엑세스하는 경우
	- 기억장치 충돌 (memory conflict) 발생
- 조건 분기 명령어가 실행
	- 미리 인출하여 처리하전 명령어들이 무효화
	- 인터럽트 시에도 비슷한 상황
> [!example]+
> - 명령어 3: 조건분기(명령어 12로 분기) 
>![[조건 분기가 존재하는 경우의 시간 흐름도.png]]
>**결과**
>- 명령어 4, 5, 6: 파이프라인에서 제거
>- 주기 7, 8, 9: 지연

## 분기 발생에 의한 성능 저하의 최소화 방법
#### 분기 목적지 선인출 (Prefetch Branch Target)
- 조건 분기가 인식되면, 분기 명령어의 다음 명령어와 분기 목적지 명령어도 함께 인출하는 방법
#### 루프 버퍼 (Loop Buffer) 사용
- **루프 버퍼**: 파이프라인의 명령어 인출 단계에 포함되어 있는 작은 고속 기억장치
- 루프 버퍼에 가장 최근 인출된 n개의 명령어들을 순서대로 저장해두는 방법
- 분기 발생 시 분기 목적지가 루프 버퍼에 존재하면 명령어를 버퍼에서 인출
#### 분기 예측 (Branch Prediction)
- 분기가 일어날 것인지를 예측하고, 그에 따라 명령어를 인출하는 확률적 방법
- **분기 역사 표 (Branch History Table)** 이용하여 최근의 분기 결과를 참조
#### 지연 분기 (Delayed Branch)
- 분기 명령어의 위치를 재배치함으로써 파이프라인의 성능을 개선하는 방법
- 분기를 나중에 실행하고 대신 다음 몇 개의 명령어를 실행
### 상태 레지스터
CPU 내부 레지스터. 조건 분기 명령어가 사용할 조건 플래그(condition flag)들 저장
조건 분기 명령어가 지정하는 조건 비트 값을 검사하여 분기 결정
> [!note]- 상태 레지스터들
>- 부호 플래그: S
>	- 직전에 수행된 산술연산 결과값의 부호 비트를 저장
>- 영 플래그: Z
>	- 연산 결과값이 0이면 1
>- 올림수 플래그: C
>	- 덧셈/뺄셈에서 올림수나 빌림수가 발생하면 1
>- 동등 플래그: E
>	- 두 수를 비교한 연산에서 결과가 같게 나왔을 경우 1
>- 오버플로우 플래그: V
>	- 산술 연산 과정에서 오버플로우가 발생하면 1
>- 인터럽트 플래그: I
>	- 인터럽트가 불가능이면 1
>- 슈퍼바이저 플래그: P
>	- CPU의 실행 모드가 슈퍼바이저 모드이면 1
>	- 사용자 모드이면 0
## 슈퍼스칼라(Superscalar)
- CPU의 처리 속도를 더욱 높이기 위하여 내부에 두 개 혹은 그 이상의 명령어 파이프라인들을 포함시킨 구조
- 매 클록 주기마다 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행할 수 있기 때문에 이론적으로 프로그램의 처리 속도가 파이프라인의 수만큼 향상 가능
- 파이프라인의 수 $M$ = $M$-way 슈퍼스칼라 
![[슈퍼스칼라의 명령어 실행 흐름도.png]]
### 슈퍼스칼라에 의한 속도 향상
- 단일 파이프라인에 의한 실행 시간 ($N$: 실행할 명령어 수)
$$T(1)=k+N-1$$
- $m$-way 슈퍼스칼라에 의한 실행 시간
$$T(m)= k+\frac{N-m}{m}$$
- 속도 향상
$$S_p=\frac{T(1)}{T(m)}=\frac{k+N-1}{k+(N-m)/m}=\frac{m(k+N-1)}{N+m(k-1)}$$
$$\lim_{N \to \infty}S_p = m$$
### 슈퍼스칼라의 속도 저하 ($S_p < m$)요인
- 명령어들 간의 데이터 의존 관계
- 하드웨어 이용에 관한 경합 발생
	- 동시 실행 가능 명령어 수 < $m$
#### 해결책
- 명령어 순서 재배치
	- 명령어들간의 데이터 의존성 제거
- 하드웨어 추가 설치
	- 기억장치 킻 레지스터에 대한 경합 감소
## 멀티 코어
각 CPU의 코어는 별도의 하드웨어 모듈로 이루어지며 시스템 버스와 캐시만 공유함
- 프로그램 실행에 있어서 각코어는 슈퍼스칼라의 파이프라인보다 더 높은 독립성을 가진다
# 명령어 세트
- CPU의 기능을 수행하기 위하여 정의되어 있는 명령어들의 집합
	- 기계명령어/어셈블리 명령어
	- CPU에 따라서 종류와 수가 다름
- 명령어 세트 설계를 위해 결정되어야 할 사항들
	- 연산 종류
	- 데이터 형태
	- 명령어 형식
	- 주소 지정 방식
## 연산의 종류
- 데이터 전송
- 산술 연산
- 논리 연산
- 입출력
- 프로그램 제어
## 프로그램 제어
- 분기
- 서브루틴 호출
### 서브루틴 호출을 위한 명령어들
- 호출 명령어: CALL
	-  현재의 PC 내용을 스택에 저장하고 서브루틴의 시작 주소로 분기하는 명령어
> [!example]+ CALL X 명령어에 대한 마이크로 연산
> 0. MBR <- PC
> 	- 현재 실행 중인 명령어의 주소를 PC에서 MBR로 복사합니다.
> 1. MAR <- SP[^2], PC <- X
> 	- SP에서 두 번째 스택 위치의 주소를 MAR로 복사한다
> 	- PC를 호출할 함수의 주소인 X로 업데이트하여 다음에 실행할 명령어를 해당 위치로 설정한다
> 1. M\[MAR\] <- MBR, SP <- SP - 1
> 	- M\[MAR\]에 MBR의 값을 저장하여 현재 명령어의 주소를 스택에 푸시한다
> 	- 이후 SP를 1 감소시켜 스택의 다음 위치를 가리키도록 한다
- 복귀 명령어: RET
	- CPU가 원래 실행했던 프로그램으로 되돌아가도록 하는 명령어
> [!example]+ RET 명령어의 마이크로 연산
> 0. SP <- SP +1
> 	- 스택에서 현재 함수의 복귀 주소를 가져오기 위해 스택 포인터에 1을 더한다
> 1. MAR <- SP
> 	- 스택에서 복귀 주소를 읽어오기 위해 SP의 값을 MAR로 복사한다
> 2. PC <- M\[MAR\]
> 	- 스택에서 꺼낸 복귀 주소로 프로그램의 실행 흐름을 되돌리기 위한 명령으로, 함수 호출 이후 복귀할 위치를 설정하기 위해 메모리에서 MAR이 가리키는 위치를 PC에 저장한다







[^1]: CPU의 원자적 기능적 연산
[^2]: 스택 포인터(Stack pointer)