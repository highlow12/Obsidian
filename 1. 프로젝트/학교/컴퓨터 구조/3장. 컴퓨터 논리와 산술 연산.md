## 목차
1. ALU의 구성 요소
2. 정수의 표현
3. 논리 연산
4. 쉬프트 연산
5. 정수의 산술 연산
6. 부동소수점 수의 표현
7. 부동소수점 산술 연산
# 컴퓨터의 기본 기능
- 산술적 계산
- 논리 데이터에 대한 연산
	- **산술논리연산장치** (ALU: Arithmetic and Logical Unit)
- 산술적 계산
	- 정수, 부동소수점 수
- 논리 연산
	- 2진 데이터
# 1. ALU의 구성 요소
- ALU
	- cpu의 구성요소중 하나
	- 컴퓨터 시스템의 다른 요소는 ALU가 처리하는 데이터를 가져오고 결과 저장, 출력
- 산술 연산
	- 산술 연산을 수행
- 논리 연산
	- 논리 연산들을 수행
- 쉬프트 레지스터
	- 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터
- 보수기(Complementer)
	- 2진 데이터를 2의 보수로 변화(음수화)
- 상태 레지스터(State register)
	- 연산 결과의 상태를 나타내는 플래그(flag) 들을 저장하는 레지스터
## ALU의 동작
**ALU가 처리하는 데이터**
- 입력: 레지스터/주기억장치 -> ALU
- 저장: ALU -> 레지스터
**상태 레지스터**
- ALU가 연산의 결과에 따라 상태 레지스터의 플래그 값을 세트
- 플래그 값은 조건분기 명령, 산술 명령에 의해 사용됨
**제어 유니트**
- 입력 데이터에 대한 연산을 수행할 내부 요소 선택, ALU 내외로 데이터 이동 데어신호 발생
# 2. 정수의 표현
- 2진수: 0, 1 부호 소수점으로 표현
<center>-13.625<sub>10</sub> = -1101.101<sub>2</sub></center>
- 컴퓨터의 데이터 저장/처리
	- 부호, 소수점 사용 안함
	- 0, 1만 사용
- 부호 없는 정수 표현의 예 (양수, 8비트)

| 2진수      | 10진수 |
| -------- | ---- |
| 00111001 | 57   |
| 00000000 | 1    |
| 00000001 | 0    |
| 10000000 | 128  |
| 11111111 | 255  |
n-비트 2진수를 부호 없는 정수 A로 변환하는 방법
$$
A=a_{n-1}\times2^{n-1}+a_{n-2}\times2^{n-2}+...+a_1\times 2^1+a_0\times2^0
$$
## 2.1 부호-크기 표현
- 부호: 맨 좌측 비트
- 크기: 나머지 n-1개의 비트
**부호-크기(magnitude) 표현 방식**

| 10진수 | 2진수       |
| ---- | --------- |
| +9   | 0000 1001 |
| -9   | 1000 1001 |
| +35  | 0010 0011 |
| -35  | 1010 0011 |
***단점***
- 덧셈과 뺄샘을 수행하기 위해서는 부호비트와 크기 부분을 별도로 처리해야함
- 0 표현이 두개 존재
	- n비트 단어로 표현할수 있는 수들이 2<sup>n</sup>개가 아니라 2<sup>n</sup> -1개로 감소
	`0000 0000 = +0`
	`1000 0000 = -0`
## 2.2 보수 표현
- 1의 보수: 모든 비트들을 반전
- 2의 보수: 모든 비트들을 반전하고 결과에 1을 더함
==양수는 1의 보수, 2의 보수가 동일함==
- **음수의 표현**

| 10진수 | 1의 보수         | 2의 보수         |
| ---- | ------------- | ------------- |
| +9   | 0000 1001     | 0000 1001     |
| -9   | 1111 011==0== | 1111 011==1== |
| +35  | 0010 0011     | 0010 0011     |
| -35  | 1101 110==0== | 1101 110==1== |
**8비트 보수로 표현된 정수의 범위**
- 1의 보수: -(2<sup>7</sup> - 1) ~ +(2<sup>7</sup> - 1)
- 2의 보수: -2<sup>7</sup> ~ +(2<sup>7</sup> - 1)
# 3. 논리 연산
- 수를 나타내는 데이터: ==단어 단위로== 취급
- 논리 데이터: ==각 비트 단위로== 취급
**기본적인 논리 연산들**

| A B | NOT A | NOT B | A AND B | A OR B | A XOR B |
| --- | ----- | ----- | ------- | ------ | ------- |
| 0 0 | 1     | 0     | 0       | 0      | 0       |
| 0 1 | 1     | 0     | 0       | 1      | 1       |
| 1 0 | 0     | 1     | 0       | 1      | 1       |
| 1 1 | 0     | 1     | 1       | 1      | 0       |
## 논리 연산을 위한 하드웨어 모듈
- 하드웨어의 구성
	- 입력 신호들은 모든 논리 게이트들을 통과
	- 선택 신호(S1, S2)에 의하여 멀티플렉서의 네 입력들 중 하나를 출력
	- 멀티플랙서<sub>multiplexer : MUX</sub>: 여러개 입력 -> 1개 출력
![[Multiplexer.png| 350 ]]

| S1 S2 | 연산          |
| ----- | ----------- |
| 0   0 | F = A AND B |
| 0   1 | F = A OR B  |
| 1   0 | F = A XOR B |
| 1   1 | F = NOT A   |
### n 비트 논리 연산장치
- n 비트 데이터를 위한 논리 연산장치
	- 기본 논리 모듈들을 병렬로 n개 접속
- 4 비트 논리 연산장치
![[Pasted image 20241125145617.png]]
**논리 연산의 활용**
- 레지스터에 저장된 데이터 단어의 특정 비트 값을 변경
- 일부 비트들을 삽입
> [!note]+ 기본 연산 방법
> AND 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 AND 연산을 수행
> ```
>     A = 1011 0101
> AND B = 0011 1011
> -------------------
>         0011 0001
> ```
> OR 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 OR 연산을 수행
> ```
>    A = 1011 0101
> OR B = 0011 1011
> -------------------
>        1011 1111
> ```
> XOR 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 exclusive-OR 연산을 수행
> ```
>     A = 1011 0101
> XOR B = 0011 1011
> -------------------
>         1010 1110
> ```
> NOT 연산
> - 데이터 단어의 모든 비트들을 반전
> ```
>NOT A = 1011 0101
> -------------------
>         0110 1010
> ```
### 데이터를 변경하기 위한 논리 연산
- **선택적 세트(selective set)**
	- B 레지스터의 비트들 중에서 1로 세트된 비트들과 같은위치에 있는 A레지스터들의 비트들을 1로 세트 <b><font color="#c0504d">OR 연산 사용</font></b>
> A = 1001 0010
> B = 0000 ==1111==
> \-\-\-\-\-\-\-\-\-\-
> A = 1001 ==1111==
- **선택적 보수(selective complement)**
	- B 레지스터의 비트들 중에서 1로 세트된 비트들에 대응되는 A레지스터들의 비트들을 보수로 변환 <b><font color="#c0504d">XOR 연산 사용</font></b>
> A = 1001 0010
> B = 0000 ==1111==
> \-\-\-\-\-\-\-\-\-\-
> A = 1001 ==1111==
- **마스크(mask)**
	- B 레지스터의 비트들 중에서 값이 0인 비트들과 같은 위치에 있는 A 레지스터의 비트들을 0으로 바꾸는(clear) 연산 <b><font color="#c0504d">AND 연산 사용</font></b>
	- 용도 : 단어내의 원하는 비트들을 선택적으로 clear하는 데 사용
> A = 1001 0010
> B = ==0000== 1111
> \-\-\-\-\-\-\-\-\-\-
> A = ==0000== 1111
- **삽입(insert)**
	- 새로운 비트 값들을 데이터 단어내의 특정 위치에 삽입 
	- 방법 : 
		1. 삽입할 비트 위치들에 대하여 <b><font color="#c0504d">AND 연산 사용</font></b> 
		2. 새로이 삽입할 비트들과 <b><font color="#c0504d">OR 연산 사용</font></b>
> A = 1001 0101
> B = ==0000== 1111  마스크(AND) 연산
> \-\-\-\-\-\-\-\-\-\-
> A = <font color="#c0504d">0000</font> 0101
> B = <font color="#4f81bd">1110</font> 0000 삽입(OR) 연산
> \-\-\-\-\-\-\-\-\-\-
> A = <font color="#c0504d">1110</font> 0101
- **비교(compare)** 
	- A와 B 레지스터의 내용을 비교 <b><font color="#c0504d">XOR 연산 사용</font></b>
	- 같으면 0, 다르면 1로 세트 
	- 결과는 A레지스터에 저장 
	- 모든 비트들이 같으면 -> 모든 비트가 0 -> 상태레지스터 Z 플래그: 1 로 세트
> A = 1101 0110
> B = 1001 1011
> \-\-\-\-\-\-\-\-\-\-
> A = 0100 1101

# 4. 쉬프트 연산
## 4.1 논리적 쉬프트
레지스터 내의 데이터 비트들을 왼쪽 혹은 오른쪽으로 한 칸씩 이동
- 좌측 시프트
	- 모든 비트들을 왼쪽으로 한칸씩 이동
	- 가장 오른쪽 비트에는 0이 들어옴
	- 가장 왼쪽 비트는 버림
- 우측 시프트
	- 좌측시프트와 같지만 방향이 반대
## 4.2 순환 시프트
회전 이라고도 부르며 최상위 혹은 최 하위 비트를 버리지 않고 반대편 끝의 비트 위치로 이동
`1100 ->(좌측 순환 시프트)-> 1001`
`1100 ->(우측 순환 시프트)-> 0110`
## 4.3 직렬 데이터 전송
- 쉬프트 연산을 데이터 비트 수만큼 연속적으로 수행함
- **두 레지스터들 사이에 ==한개의 선을 통하여== *전체 데이터를 이동*하는 동작**
![[Pasted image 20241125222756.png]]
## 4.4 산술적 쉬프트
수를 나타내는 데이터(부호를 가진 정수)에 대한 쉬프트 연산
- 방법
	- 부호 비트: 유지
	- 크기를 나타내는 비트만 쉬프트
# 정수의 산술 연산
## 덧셈
> [!important]+ 2의 보수로 표현된 수들의 덧셈 방법
> - 두 수를 더하고 만약 올림수가 발생하면 버림
> ```
> 3 + 4 = 7
>   0011
> + 0100
> -------
>   0111 = 7
>
> -3 + 3 = 0
>   1101
> + 0011
> -------
> 1 0000 = 0 (올림수 1은 버림)
>
>-4 + -1 = -5
>   1100
>+ 1111
> -------
> 1 1011 = -5
> ```

> [!NOTE]+ 덧셈 오버플로우
> <font color="#c0504d">덧셈 결과가 그 범위를 초과하여 결과값이 틀리게 되는 상태</font>
> **검출 방법** (4비트 정수인 경우)
> 두 올림수[^1]들 간의 XOR 연산을 이용
> V = 세 번째 비트의 올림수 XOR 네번째 비트의 올림수
> V가 1일 경우 오버플로우 발생. CPU는 결과를 다른 연사에 사용하지 않도록 조치
> ```
> 6 + 3 = 9
>   0110
>+ 0011
>-------
>   1001 = -7 (오버플로우)
>   
> -7 + -6 = -13
>   1001
>+ 1010
>-------
> 1 0011 = 3 (오버플로우)
> ```
## 뺄셈
A - B의 경우 B를 2의 보수화 시키면 -B가 되고 이 수를 A와 더한다. 
즉 A - B = A + (-B) 를 이용한다
오버플로우를 검출하는 방법도 덧셈과 같다
## 곱셈
### 부호 없는 정수의 곱셈
- 각 비트에 대하여 부분 적(partical product) 계산
- 부분 적들을 모두 더하여 최종 결과를 얻음
- 2개의 n비트 2진 정수의 곱셈 -> 최대 2n비트 결과
```
    1101 (피승수 = 13)
  x 1011 (승수 = 11)
---------
    1101
   1101
  0000    (부분 적들)
 1101
---------
10001111 (최종 결과 = 143)
```
![[3컴퓨터산술과논리연산.pdf#page=39]]
![[3컴퓨터산술과논리연산.pdf#page=40]]
### 2의 보수들 간의 곱셈
Booth 알고리즘 사용
- 하드웨어 구성
	- M 레지스터와 병렬 가산기 사이에 보수기 추가
	- Q레지스터의 우측에 Q<sub>-1</sub> 이라고 부르는 1비트 레지스터를 추가하고 출력을 Q<sub>0</sub>과 함께 제어 회로로 출력

[^1]: 받아올림 하는 수