## 목차
1. ALU의 구성 요소
2. 정수의 표현
3. 논리 연산
4. 쉬프트 연산
5. 정수의 산술 연산
6. 부동소수점 수의 표현
7. 부동소수점 산술 연산
# 컴퓨터의 기본 기능
- 산술적 계산
- 논리 데이터에 대한 연산
	- **산술논리연산장치** (ALU: Arithmetic and Logical Unit)
- 산술적 계산
	- 정수, 부동소수점 수
- 논리 연산
	- 2진 데이터
# 1. ALU의 구성 요소
- ALU
	- cpu의 구성요소중 하나
	- 컴퓨터 시스템의 다른 요소는 ALU가 처리하는 데이터를 가져오고 결과 저장, 출력
- 산술 연산
	- 산술 연산을 수행
- 논리 연산
	- 논리 연산들을 수행
- 쉬프트 레지스터
	- 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터
- 보수기(Complementer)
	- 2진 데이터를 2의 보수로 변화(음수화)
- 상태 레지스터(State register)
	- 연산 결과의 상태를 나타내는 플래그(flag) 들을 저장하는 레지스터
## ALU의 동작
**ALU가 처리하는 데이터**
- 입력: 레지스터/주기억장치 -> ALU
- 저장: ALU -> 레지스터
**상태 레지스터**
- ALU가 연산의 결과에 따라 상태 레지스터의 플래그 값을 세트
- 플래그 값은 조건분기 명령, 산술 명령에 의해 사용됨
**제어 유니트**
- 입력 데이터에 대한 연산을 수행할 내부 요소 선택, ALU 내외로 데이터 이동 데어신호 발생
# 2. 정수의 표현
- 2진수: 0, 1 부호 소수점으로 표현
<center>-13.625<sub>10</sub> = -1101.101<sub>2</sub></center>
- 컴퓨터의 데이터 저장/처리
	- 부호, 소수점 사용 안함
	- 0, 1만 사용
- 부호 없는 정수 표현의 예 (양수, 8비트)

| 2진수      | 10진수 |
| -------- | ---- |
| 00111001 | 57   |
| 00000000 | 1    |
| 00000001 | 0    |
| 10000000 | 128  |
| 11111111 | 255  |
n-비트 2진수를 부호 없는 정수 A로 변환하는 방법
$$
A=a_{n-1}\times2^{n-1}+a_{n-2}\times2^{n-2}+...+a_1\times 2^1+a_0\times2^0
$$
## 2.1 부호-크기 표현
- 부호: 맨 좌측 비트
- 크기: 나머지 n-1개의 비트
**부호-크기(magnitude) 표현 방식**

| 10진수 | 2진수       |
| ---- | --------- |
| +9   | 0000 1001 |
| -9   | 1000 1001 |
| +35  | 0010 0011 |
| -35  | 1010 0011 |
***단점***
- 덧셈과 뺄샘을 수행하기 위해서는 부호비트와 크기 부분을 별도로 처리해야함
- 0 표현이 두개 존재
	- n비트 단어로 표현할수 있는 수들이 2<sup>n</sup>개가 아니라 2<sup>n</sup> -1개로 감소
	`0000 0000 = +0`
	`1000 0000 = -0`
## 2.2 보수 표현
- 1의 보수: 모든 비트들을 반전
- 2의 보수: 모든 비트들을 반전하고 결과에 1을 더함
==양수는 1의 보수, 2의 보수가 동일함==
- **음수의 표현**

| 10진수 | 1의 보수         | 2의 보수         |
| ---- | ------------- | ------------- |
| +9   | 0000 1001     | 0000 1001     |
| -9   | 1111 011==0== | 1111 011==1== |
| +35  | 0010 0011     | 0010 0011     |
| -35  | 1101 110==0== | 1101 110==1== |
**8비트 보수로 표현된 정수의 범위**
- 1의 보수: -(2<sup>7</sup> - 1) ~ +(2<sup>7</sup> - 1)
- 2의 보수: -2<sup>7</sup> ~ +(2<sup>7</sup> - 1)
# 3. 논리 연산
- 수를 나타내는 데이터: ==단어 단위로== 취급
- 논리 데이터: ==각 비트 단위로== 취급
**기본적인 논리 연산들**

| A B | NOT A | NOT B | A AND B | A OR B | A XOR B |
| --- | ----- | ----- | ------- | ------ | ------- |
| 0 0 | 1     | 0     | 0       | 0      | 0       |
| 0 1 | 1     | 0     | 0       | 1      | 1       |
| 1 0 | 0     | 1     | 0       | 1      | 1       |
| 1 1 | 0     | 1     | 1       | 1      | 0       |
## 논리 연산을 위한 하드웨어 모듈
- 하드웨어의 구성
	- 입력 신호들은 모든 논리 게이트들을 통과
	- 선택 신호(S1, S2)에 의하여 멀티플렉서의 네 입력들 중 하나를 출력
	- 멀티플랙서<sub>multiplexer : MUX</sub>: 여러개 입력 -> 1개 출력
![[Multiplexer.png| 350 ]]

| S1 S2 | 연산          |
| ----- | ----------- |
| 0   0 | F = A AND B |
| 0   1 | F = A OR B  |
| 1   0 | F = A XOR B |
| 1   1 | F = NOT A   |
### n 비트 논리 연산장치
- n 비트 데이터를 위한 논리 연산장치
	- 기본 논리 모듈들을 병렬로 n개 접속
- 4 비트 논리 연산장치
![[Pasted image 20241125145617.png]]
**논리 연산의 활용**
- 레지스터에 저장된 데이터 단어의 특정 비트 값을 변경
- 일부 비트들을 삽입
> [!note]+ 기본 연산 방법
> AND 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 AND 연산을 수행
> ```
>     A = 1011 0101
> AND B = 0011 1011
> -------------------
>         0011 0001
> ```
> OR 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 OR 연산을 수행
> ```
>    A = 1011 0101
> OR B = 0011 1011
> -------------------
>        1011 1111
> ```
> XOR 연산
> - 두 데이터 단어들의 대응되는 비트들 간에 exclusive-OR 연산을 수행
> ```
>     A = 1011 0101
> XOR B = 0011 1011
> -------------------
>         1010 1110
> ```
> NOT 연산
> - 데이터 단어의 모든 비트들을 반전
> ```
>NOT A = 1011 0101
> -------------------
>         0110 1010
> ```
### 데이터를 변경하기 위한 논리 연산
- **선택적 세트(selective set)**
	- B 레지스터의 비트들 중에서 1로 세트된 비트들과 같은위치에 있는 A레지스터들의 비트들을 1로 세트 **OR 연산 사용**
A = 1001 0010
B = 0000 ==1111==
\-\-\-\-\-\-\-\-\-\-
A = 1001 ==1111==
- **선택적 보수(selective complement)**
- **마스크(mask)**
- **삽입(insert)**
- **비교(compare)** 