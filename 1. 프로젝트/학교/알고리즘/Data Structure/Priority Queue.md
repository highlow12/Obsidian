---
tags:
  - "#DataStructure/Queue"
  - "#DataStructure/Non-Linear"
  - DataStructure/Tree
aliases:
  - 우선순위 큐
---
# 우선순위 큐 ADT
- 객체: n개의 element형의 우선순위를 가진 요소들의 모임
- 연산
	- `creat()`: 우선순위 큐를 생성
	- `init(q)`:우선순위큐 `q`를 초기화
	-  is_empty(q): 우선 순위큐 q가 비어있는지를 검사
	- `is_full(q)`: 우선 순위큐 q가 가득 찼는가를 검사
	- `insert(q, x)`: 우선 순위큐 q에 요소 x를 추가
	- `delete(q`): 우선 순위큐로부터 가장 우선순위가 높은 요소를 삭제하고 이 요소를 반환
	- `find(q)`: 우선 순위가 가장 높은 요소를 반환
# 우선순위 큐 구현방법
- 배열을 이용
- 연결 리스트를 이용
- 힙([[Heap]])을 이용

| 표현 방법       | 삽입       | 삭제       |
| ----------- | -------- | -------- |
| 순서없는 배열     | O(1)     | O(n)     |
| 순서없는 연결 리스트 | O(1)     | O(n)     |
| 정렬된 배열      | O(n)     | O(1)     |
| 정렬된 연결 리스트  | O(n)     | O(1)     |
| 힙           | O(log n) | O(log n) |
# Heap
![[Heap]]
# 힙을 이용하여 우선순위 큐를 구현하는 방법
## 힙에 요소 삽입하기
- **삽입 과정**:
  1. 요소를 트리의 마지막 위치에 추가.
  2. 힙 속성을 유지하기 위해 부모 노드와 비교하여 필요시 자리 교환 ("힙 업").
  3. 부모 노드보다 작거나 클 때까지 (최소/최대 힙) 반복.
## 힙에서 요소 제거하기
- **제거 과정**:
  1. 루트 요소(최우선 요소)를 제거.
  2. 트리의 마지막 요소를 루트로 이동.
  3. 힙 속성을 유지하기 위해 자식 노드들과 비교하여 필요시 자리 교환 ("힙 다운").
  4. 자식 노드보다 작거나 클 때까지 (최소/최대 힙) 반복.
## 우선순위 큐 연산의 시간 복잡도
- **삽입**: O(log n) - 힙의 높이가 log n이므로 최대 log n번의 비교 및 교환 필요.
- **삭제**: O(log n) - 삭제 연산도 최대 log n번의 비교 및 교환 필요.
- **최고 우선순위 요소 접근**: O(1) - 루트 요소는 항상 최우선 요소이므로 접근은 O(1).